//  计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。
//每个层次之间都须要相互通信，既然须要通信就必须有一个通信的协议，我们一般将其称为接口。
//操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口定义决定了操作系统内核，具体来说就是驱动程序如何操作硬件，如何与硬件进行通信，
//这种接口往往被叫做硬件规格（Hardware Specification），硬件的生产厂商负责提供硬件规格，操作系统和驱动程序的开发者通过阅读硬件规格文档所规定的各种硬件编程接口标准来
//编写操作系统和驱动程序。
//当成熟的操作系统出现以后，硬件逐渐被抽象成了一系列概念。在UNIX中，硬件设备的访问形式跟访问普通的文件形式一样；在Windows系统中，图形硬件被抽象成了GDI，声音和多媒体设备
//被抽象成了DirectX对象；磁盘被抽象成了普通文件系统，等等。程序员逐渐从硬件细节中解放出来，可以更多地关注应用程序本身的开发。这些繁琐的硬件细节全都交给了操作系统，具体地讲是操作
//系统中的硬件驱动程序来完成。驱动程序可以看做是操作系统的一部分，它往往跟操作系统内核一起运行在特权级，但它又与操作系统内核之间有一定的独立性，使得驱动程序有比较好的灵活性。
//因为PC的硬件多如牛毛，操作系统开发者不可能为每个硬件开发一个驱动程序，这些驱动程序的开发工作通常由硬件生产厂商完成。操作系统开发者为硬件生产厂商提供了一系列接口和框架，
//凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。
//同步与锁
//二元信号量（Binary Semaphore）
//信号量（Semaphore）
//互斥量（Mutex）
//临界区（Critical Section）
//读写锁（Read-Write Lock）
//条件变量（Condition Variable）
//可重入（Reentrant）与线程安全
//一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。一个函数要被重入，只有两重情况：
//多个线程同时执行这个函数。
//函数自身（可能是经过多层调用之后）调用自身。
//不使用任何（局部）静态或全局的非const变量。
//不返回任何（局部）静态或全局的非const变量的指针。
//仅依赖于调用方提供的参数。
//不依赖任何单个资源的锁（mutex等）。
//不调用任何不可重入函数。
// 现在的问题是不同的变量可能存储在同一个数据段中，这些变量原来的位置是不连续的，这样的存储会不会有问题。
//这个数据段是全局变量的数据段，因此不会有问题。
//函数内的变量是代码段的一部分。
//
